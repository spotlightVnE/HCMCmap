<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bản đồ Phân tích Dữ liệu Phường/Xã</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: 'Helvetica Neue', Arial, sans-serif;
            overflow: hidden;
        }

        #map {
            height: 100vh;
            width: 100vw;
            z-index: 1;
            background-color: #f9fafb;
        }

        /* --- Thanh tìm kiếm ở trên --- */
        #top-bar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1001;
            display: flex;
            justify-content: center;
            padding: 1rem;
            pointer-events: none;
        }

        #search-container {
            width: 100%;
            max-width: 450px;
            position: relative;
            pointer-events: auto;
        }

        #search-box {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: rgba(255, 255, 255, 0.25); /* 25% trong suốt */
            backdrop-filter: blur(8px);
            border: 1px solid #e5e7eb;
            border-radius: 0.75rem;
            padding: 0.5rem 1rem;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        #wardSearchInput {
            width: 100%;
            background: transparent;
            font-size: 1rem;
            font-weight: 500;
            color: #1f2937;
            outline: none;
            border: none;
        }

        #search-results {
            display: none;
            position: absolute;
            top: 110%;
            left: 0;
            right: 0;
            background: white;
            border-radius: 0.75rem;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            max-height: 40vh;
            overflow-y: auto;
            border: 1px solid #e5e7eb;
        }
        #search-results button.focused-search-result {
            background-color: #e0e7ff; /* Light indigo background for focus */
            outline: 2px solid #4f46e5; /* Indigo outline */
            outline-offset: -1px;
        }

        /* --- Thanh điều khiển ở dưới --- */
        #bottom-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 1001;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.5); /* 50% trong suốt */
            backdrop-filter: blur(8px);
            border-top: 1px solid #e5e7eb;
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: center;
            gap: 1.5rem;
            transition: all 0.3s ease;
        }

        #heatmap-controls {
            display: flex;
            gap: 0.5rem;
        }

        #heatmap-controls button {
            padding: 0.6rem 1rem;
            border-radius: 0.5rem;
            border: 1px solid #d1d5db;
            background-color: #fff;
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            color: #4b5563;
        }

        #heatmap-controls button:hover {
            background-color: #f3f4f6;
        }

        #heatmap-controls button.active {
            background-color: #334155;
            color: white;
            border-color: #1e293b;
        }

        #legend-container {
            flex-grow: 1;
            max-width: 300px;
            font-size: 12px;
            visibility: hidden; /* Dùng visibility để không làm layout bị nhảy */
        }

        #legend-container .title {
            font-weight: bold;
            margin-bottom: 5px;
            color: #1f2937;
        }

        #legend-bar-wrapper {
            position: relative;
            padding: 10px 0;
        }

        #legend-container .gradient {
            width: 100%;
            height: 10px;
            border-radius: 5px;
            border: 1px solid #ccc;
        }

        #legend-container .labels {
            display: flex;
            justify-content: space-between;
            font-weight: bold;
            font-size: 11px;
        }

        #legend-indicator {
            display: none;
            position: absolute;
            top: 5px;
            height: 18px;
            width: 2px;
            background-color: #ef4444;
            transform: translateX(-1px);
            z-index: 10;
        }

        #legend-hover-value {
            display: none;
            position: absolute;
            top: -13px;
            transform: translateX(-50%);
            background-color: #ef4444;
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            white-space: nowrap;
        }

        /* --- Responsive cho di động --- */
        @media (max-width: 768px) {
            #bottom-bar {
                flex-direction: column;
                gap: 1rem;
                padding: 0.75rem;
            }
            #legend-container {
                width: 100%;
                max-width: none;
                order: -1;
            }

            #top-bar {
                padding: 0.75rem;
            }

            .info-popup .leaflet-popup-content {
                width: 90vw !important;
            }
        }

        /* --- Các style khác --- */
        .spinner {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 50px;
            height: 50px;
            border: 5px solid rgba(0, 0, 0, 0.1);
            border-left-color: #4f46e5;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            z-index: 2000;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .ward-label {
            background-color: rgba(0, 0, 0, 0.6);
            border: none;
            border-radius: 4px;
            color: white;
            font-size: 14px;
            font-weight: bold;
            padding: 5px 10px;
            box-shadow: none;
            white-space: nowrap;
        }

        .ward-label::before {
            border: none !important;
        }

        .info-popup .leaflet-popup-content-wrapper {
            border-radius: 0.75rem;
            padding: 0;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .info-popup .leaflet-popup-content {
            margin: 0;
            font-size: 14px;
        }

        .info-popup-header {
            background-color: #f9fafb;
            padding: 0.75rem 1.25rem;
            border-bottom: 1px solid #e5e7eb;
        }

        .info-popup-title {
            font-size: 1.125rem;
            font-weight: 700;
            color: #111827;
        }

        .info-popup-body {
            padding: 1rem 1.25rem;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .info-line {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .info-label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 500;
            color: #4b5563;
        }

        .info-label i {
            color: #6b7280;
        }

        .info-value {
            font-weight: 600;
            color: #1f2937;
        }

        .info-section {
            border-top: 1px solid #f3f4f6;
            padding-top: 0.75rem;
            color: #4b5563;
            line-height: 1.5;
        }

        .info-popup-footer {
            padding: 0.75rem;
            background-color: #f9fafb;
            border-top: 1px solid #e5e7eb;
        }

        .navigate-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            width: 100%;
            background-color: #4f46e5;
            color: #ffffff;
            font-weight: 600;
            padding: 0.6rem;
            border-radius: 0.5rem;
            text-decoration: none;
            transition: background-color 0.2s;
        }

        .navigate-btn:hover {
            background-color: #4338ca;
        }

        #inset-map-container {
            position: absolute;
            bottom: 140px; 
            right: 20px;
            width: 150px; 
            height: 100px; 
            border: 1px solid #999;
            background-color: rgba(238,242,247,0.5); /* A slightly different background */
            z-index: 1000; /* Below main controls (1001), same level as popups */
            box-shadow: 0 2px 8px rgba(0,0,0,0.25);
            border-radius: 3px;
            overflow: hidden;
            display: none; /* Initially hidden, JS will control visibility */
        }
        #inset-map-label {
            position: absolute;
            top: 5px; /* Adjust as needed */
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.2);
            color: white;
            padding: 2px 2px;
            font-size: 7.5px;
            font-weight: bold;
            border-radius: 2px;
            z-index: 1001; /* Above inset map tiles */
        }

        #inset-map {
            width: 100%;
            height: 100%;
        }
    </style>
</head>

<body>

    <div id="map"></div>
    <div id="loading" class="spinner"></div>

    <div id="inset-map-container">
        <div id="inset-map-label">Đặc khu Côn Đảo</div>
        <div id="inset-map"></div>
    </div>

    <div id="top-bar">
        <div id="search-container">
            <div id="search-box">
                <i class="fa-solid fa-magnifying-glass text-gray-400"></i>
                <input type="text" id="wardSearchInput" placeholder="Tìm phường xã (cũ/mới) hoặc quận huyện">
            </div>
            <div id="search-results"></div>
        </div>
    </div>

    <div id="bottom-bar">
        <div id="heatmap-controls">
            <button id="btn-density" data-key="Mật độ (người/km2)">Mật độ</button>
            <button id="btn-population" data-key="Dân số (người)">Dân số</button>
            <button id="btn-area" data-key="Diện tích (km2)">Diện tích</button>
        </div>
        <div id="legend-container"></div>
    </div>

    <script>
        const START_COLOR = { r: 247, g: 251, b: 255 };
        const END_COLOR = { r: 8, g: 48, b: 107 };
        const NO_DATA_COLOR = '#cccccc';
        const DEFAULT_WARD_STYLE = {
            weight: 1,
            color: '#0f0f0f', // White border
            opacity: 0.7,
            fillColor: 'transparent', // No fill color
            fillOpacity: 0 // No fill
        };

        // --- Inset Map Configuration ---
        // IMPORTANT: User must define how to identify Côn Đảo's feature in their data.
        // Option 1: By STT (if STT is a unique number for Côn Đảo in your HCMC_data.tsv)
        const CON_DAO_STT_TARGET = null; // Example: 768 (REPLACE with actual STT number for Côn Đảo or the desired region)
        // Option 2: By Name (if Côn Đảo has a recognizable name in properties.Tên)
        const CON_DAO_NAME_TARGET = "Côn Đảo"; // Example: "Côn Đảo" (REPLACE/ADJUST as needed for your data)

        const CON_DAO_INSET_STYLE = { // Style for the feature on the inset map
            weight: 1, color: '#0f0f0f', opacity: 1, fillColor: '#ff7f7f', fillOpacity: 0
        };

        // URLs for Province and District GeoJSON files
        const PROVINCES_GEOJSON_URL = 'https://raw.githubusercontent.com/lqtue/phuongnao/main/Provinces.geojson';
        const DISTRICTS_GEOJSON_URL = 'https://raw.githubusercontent.com/lqtue/phuongnao/main/Districts.geojson';

        let wardData, provinceData, districtData, currentTileLayer; // Added currentTileLayer
        let map, searchHighlightLayer, wardsLayer, choroplethInfo = {}; // Renamed highlightedLayer
        let insetMap, conDaoFeatureForInset = null, conDaoLayerOnInset, insetMapContainerElement;
        let displayedSearchResults = [], currentFocusedResultIndex = -1; // Added currentFocusedResultIndex

        function normalizeString(str) { 
            // console.log("Original:", str);
            if (!str) {
                return '';
            }
            let n = str.toLowerCase();

            // Step 1: Diacritics and 'đ'
            n = n.normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/đ/g, "d");
            // console.log("After diacritics:", n);

            // Step 2: Convert full Vietnamese terms (now without diacritics) to common short forms or standard forms
            // "thành phố" (as "thanh pho") -> "tp"
            n = n.replace(/\bthanh pho\b/g, "tp"); 
            // "phường" (as "phuong"), "quận" (as "quan"), "huyện" (as "huyen") are already in their desired form.
            // console.log("After full terms to short forms:", n);

            // Step 3: Handle common abbreviations like "tp.", "p.", "q.", "h."
            n = n.replace(/\btp\.\b/g, "tp");
            n = n.replace(/\bp\.\b/g, "phuong");
            n = n.replace(/\bq\.\b/g, "quan");
            n = n.replace(/\bh\.\b/g, "huyen");
            // console.log("After abbreviations:", n);

            // Step 4: Specific normalization for "Ho Chi Minh City" variants
            // Ensures "tp hcm", "tp ho chi minh" (from various inputs) all become "tp ho chi minh"
            if (n.startsWith("tp ") && (n.includes("hcm") || n.includes("ho chi minh"))) {
                 n = n.replace(/\bhcm\b/g, "ho chi minh"); // Replace "hcm" part with "ho chi minh"
            }
            // console.log("After HCM normalization:", n);
            
            // Step 5: Final cleanup - remove unwanted characters, normalize spaces
            n = n.replace(/[^a-z0-9 ]/g, '').replace(/\s+/g, ' ').trim();
            // console.log("Final normalized:", n);
            return n;
        }

        function isAccurateMatch(normalizedQuery, normalizedTarget) {
            if (!normalizedQuery || !normalizedTarget) return false;

            const qLen = normalizedQuery.length;
            const tLen = normalizedTarget.length;

            // Case 1: Exact match
            if (normalizedTarget === normalizedQuery) {
                return true;
            }

            // Case 2: Target starts with query as a whole word/phrase
            // (e.g., query "an phu" matches target "an phu dong")
            if (normalizedTarget.startsWith(normalizedQuery)) {
                if (tLen === qLen || (tLen > qLen && normalizedTarget[qLen] === ' ')) {
                    return true;
                }
            }

            // Case 3: Target ends with query as a whole word/phrase
            // (e.g., query "an phu" matches target "phuong an phu")
            if (normalizedTarget.endsWith(normalizedQuery)) {
                if (tLen === qLen || (tLen > qLen && normalizedTarget[tLen - qLen - 1] === ' ')) {
                    return true;
                }
            }

            // Case 4: Query is a whole word/phrase in the middle of the target
            // (e.g., query "an phu" matches target "khu dan cu an phu moi")
            if ((" " + normalizedTarget + " ").includes(" " + normalizedQuery + " ")) {
                return true;
            }
            return false;
        }

        function setLoading(isLoading) {
            document.getElementById('loading').style.display = isLoading ? 'block' : 'none';
        }

        function interpolateColor(color1, color2, factor) {
            factor = Math.max(0, Math.min(1, factor));
            const r = Math.round(color1.r + factor * (color2.r - color1.r));
            const g = Math.round(color1.g + factor * (color2.g - color1.g));
            const b = Math.round(color1.b + factor * (color2.b - color1.b));
            return `rgb(${r}, ${g}, ${b})`;
        }

        function getChoroplethColor(value, key) {
            const info = choroplethInfo[key];
            if (!info || typeof value !== 'number' || !isFinite(value)) {
                return NO_DATA_COLOR;
            }

            if (info.numBins === 0) { // Should not happen if values exist
                return NO_DATA_COLOR;
            }

            if (info.numBins === 1) { // Only one bin, e.g., all values are the same
                return interpolateColor(START_COLOR, END_COLOR, 0.5); // Use a mid-color
            }

            const breaks = info.breaks;
            let binIndex = 0;
            // Find which bin the value falls into
            // breaks are upper bounds: val <= breaks[0] is bin 0, breaks[0] < val <= breaks[1] is bin 1, etc.
            for (let i = 0; i < breaks.length; i++) {
                if (value <= breaks[i]) {
                    binIndex = i;
                    break;
                }
                binIndex = i + 1; // If value is greater than breaks[i], it's in the next bin or the last bin
            }

            // factor is based on the bin index: 0 for the first bin, 1 for the last.
            const factor = binIndex / (info.numBins - 1);
            return interpolateColor(START_COLOR, END_COLOR, factor);
        }

        // --- HÀM LEGEND ĐÃ CẬP NHẬT ---
        function updateLegend(title, min, max) {
            const legendDiv = document.getElementById('legend-container');
            if (!legendDiv) {
                return;
            }

            const show = title && typeof min === 'number' && typeof max === 'number';
            legendDiv.style.visibility = show ? 'visible' : 'hidden';
            if (!show) return;

            let displayName = title;
            let unit = '';
            const unitStartIndex = title.indexOf('(');
            if (unitStartIndex !== -1) {
                displayName = title.substring(0, unitStartIndex).trim();
                unit = title.substring(unitStartIndex);
            }

            const minLabel = Math.round(min).toLocaleString('vi-VN');
            const maxLabel = Math.round(max).toLocaleString('vi-VN');

            const startRgb = `rgb(${START_COLOR.r},${START_COLOR.g},${START_COLOR.b})`;
            const endRgb = `rgb(${END_COLOR.r},${END_COLOR.g},${END_COLOR.b})`;
            const gradientCss = `linear-gradient(to right, ${startRgb}, ${endRgb})`;

            legendDiv.innerHTML = `

                <div id="legend-bar-wrapper">
                    <div class="gradient" style="background: ${gradientCss};"></div>
                    <div id="legend-indicator"></div>
                    <div id="legend-hover-value"></div>
                </div>
                <div class="labels">
                    <span>${minLabel}</span>
                    <span>${maxLabel} ${unit}</span>
                </div>`;
        }

        function renderMapVisualization() {
            const activeBtn = document.querySelector('#heatmap-controls button.active');
            
            if (!wardsLayer) return;

            if (activeBtn && activeBtn.dataset.key) { // A heatmap button is active
                const categoryKey = activeBtn.dataset.key;
                if (!choroplethInfo[categoryKey]) {
                    // Fallback to default style if data for this key is missing
                    wardsLayer.setStyle(DEFAULT_WARD_STYLE);
                    updateLegend(null);
                    return;
                }
                const info = choroplethInfo[categoryKey];
                wardsLayer.setStyle(feature => ({
                    fillColor: getChoroplethColor(feature.properties[categoryKey], categoryKey),
                    weight: 0.5,
                    opacity: 1,
                    color: '#0f0f0f', // Border color for heatmap cells
                    fillOpacity: 0.8
                }));
                updateLegend(categoryKey, info.min, info.max);
            } else { // "Boundaries" button is active or no specific heatmap button is active
                wardsLayer.setStyle(DEFAULT_WARD_STYLE);
                updateLegend(null);
            }
        }
        async function loadData() {
            try {
                const [
                    geoRes, dataRes,
                    provincesRes, districtsRes
                ] = await Promise.all([
                    fetch('https://raw.githubusercontent.com/lqtue/phuongnao/main/HCMC_v4.geojson'),
                    fetch('https://raw.githubusercontent.com/lqtue/phuongnao/main/HCMC_data.tsv'),
                    fetch(PROVINCES_GEOJSON_URL),
                    fetch(DISTRICTS_GEOJSON_URL)
                ]);

                if (!geoRes.ok || !dataRes.ok || !provincesRes.ok || !districtsRes.ok) {
                    throw new Error(`Network Error`);
                }
                const geojsonData = await geoRes.json();
                const tsvData = parseTSV(await dataRes.text());
                provinceData = await provincesRes.json(); // Store province data
                districtData = await districtsRes.json(); // Store district data

                const dataMap = new Map(tsvData.map(row => [row['STT'], row]));
                geojsonData.features.forEach(f => Object.assign(f.properties, dataMap.get(f.properties['STT'])));
                wardData = geojsonData;

                // Try to find the feature for the inset map (e.g., Côn Đảo)
                if (CON_DAO_STT_TARGET !== null) {
                    conDaoFeatureForInset = wardData.features.find(f => f.properties.STT === CON_DAO_STT_TARGET);
                }
                if (!conDaoFeatureForInset && CON_DAO_NAME_TARGET) {
                    const normalizedTargetName = normalizeString(CON_DAO_NAME_TARGET);
                    conDaoFeatureForInset = wardData.features.find(f => {
                        const featureName = f.properties['Tên'];
                        return featureName && normalizeString(featureName).includes(normalizedTargetName);
                    });
                }
                if (!conDaoFeatureForInset) {
                    console.warn(`Feature for inset map (e.g., Côn Đảo with STT '${CON_DAO_STT_TARGET}' or name '${CON_DAO_NAME_TARGET}') not found. Inset map will not be displayed.`);
                }
                prepareChoroplethData();
            } catch (e) {
                setLoading(false);
                alert(`Lỗi tải dữ liệu: ${e.message}`);
                throw e;
            }
        }

        function parseTSV(tsvText) {
            const lines = tsvText.trim().split(/\r?\n/);
            const headers = lines[0].split('\t').map(h => h.trim());
            const rows = [];
            for (let i = 1; i < lines.length; i++) {
                if (lines[i].trim() === '') {
                    continue;
                }
                const values = lines[i].split('\t');
                const rowObject = {};
                for (let j = 0; j < headers.length; j++) {
                    rowObject[headers[j]] = isNaN(parseFloat(values[j])) ? (values[j] || '').trim() : parseFloat(values[j]);
                }
                rows.push(rowObject);
            }
            return rows;
        }

        function prepareChoroplethData() {
            const keys = ['Mật độ (người/km2)', 'Dân số (người)', 'Diện tích (km2)'];
            const NUM_QUANTILES = 10; // Desired number of quantiles (bins)

            keys.forEach(key => {
                const values = wardData.features
                    .map(f => f.properties[key])
                    .filter(v => typeof v === 'number' && isFinite(v))
                    .sort((a, b) => a - b);

                if (values.length === 0) {
                    choroplethInfo[key] = { min: 0, max: 0, breaks: [], numBins: 0 };
                    return;
                }

                const minVal = values[0];
                const maxVal = values[values.length - 1];
                const breaks = [];

                if (minVal === maxVal || values.length < NUM_QUANTILES) {
                    // Not enough distinct values or data for full quantiles.
                    // Create breaks from unique sorted values (up to NUM_QUANTILES-1 breaks)
                    // The breaks are the upper bounds of the bins.
                    const uniqueSortedValues = [...new Set(values)].sort((a, b) => a - b);
                    for (let i = 0; i < uniqueSortedValues.length - 1 && breaks.length < NUM_QUANTILES - 1; i++) {
                        breaks.push(uniqueSortedValues[i]);
                    }
                     // Ensure the last unique value is a break if we still have few breaks and it's not already the last one
                    if (uniqueSortedValues.length > breaks.length +1 && breaks.length < NUM_QUANTILES -1 && uniqueSortedValues[uniqueSortedValues.length-1] !== breaks[breaks.length-1]) {
                        breaks.push(uniqueSortedValues[uniqueSortedValues.length-1]);
                    }
                } else {
                    // Calculate NUM_QUANTILES - 1 break points.
                    const n = values.length;
                    for (let i = 1; i < NUM_QUANTILES; i++) {
                        const rank = Math.ceil(n * i / NUM_QUANTILES) - 1;
                        const potentialBreak = values[Math.min(rank, n - 1)];
                        if (breaks.length === 0 || potentialBreak > breaks[breaks.length - 1]) {
                            breaks.push(potentialBreak);
                        } else if (potentialBreak === breaks[breaks.length - 1] && breaks.length < NUM_QUANTILES - 1) {
                             // If duplicate, try to find the next distinct value if we still need more breaks
                            for (let j = rank + 1; j < n && values[j] === potentialBreak; j++) { rank++; } // Skip duplicates
                            if (rank +1 < n && values[rank+1] > breaks[breaks.length-1]) breaks.push(values[rank+1]);
                        }
                    }
                }
                // Ensure the very last break is indeed the max value if it wasn't included and we have space
                if (breaks.length > 0 && breaks[breaks.length-1] < maxVal && breaks.length < NUM_QUANTILES -1) {
                    breaks.push(maxVal);
                }
                 // Remove duplicates and sort, ensure maxVal is the absolute last break if it's part of breaks.
                const finalBreaks = [...new Set(breaks)].sort((a,b) => a-b);
                if (finalBreaks.length > 0 && finalBreaks[finalBreaks.length-1] !== maxVal && !finalBreaks.includes(maxVal) && finalBreaks.length < NUM_QUANTILES -1) {
                    finalBreaks.push(maxVal);
                    finalBreaks.sort((a,b)=>a-b);
                }


                choroplethInfo[key] = {
                    min: minVal,
                    max: maxVal,
                    breaks: finalBreaks,
                    numBins: finalBreaks.length + 1
                };
            });
        }

        function onWardMouseover(e) {
            const properties = e.target.feature.properties;
            const activeBtn = document.querySelector('#heatmap-controls button.active');
            if (!activeBtn || !activeBtn.dataset.key) { // If no active button or it's not a heatmap button
                return;
            }
            const key = activeBtn.dataset.key;
            const value = properties[key];
            const info = choroplethInfo[key];
            const indicator = document.getElementById('legend-indicator');
            const hoverValue = document.getElementById('legend-hover-value');
            if (!indicator || typeof value !== 'number' || !info) {
                return;
            }
            const percent = (info.max > info.min) ? (value - info.min) / (info.max - info.min) * 100 : 0;
            indicator.style.left = `${percent}%`;
            indicator.style.display = 'block';
            hoverValue.innerText = Math.round(value).toLocaleString('vi-VN');
            hoverValue.style.left = `${percent}%`;
            hoverValue.style.display = 'block';
        }

        function onWardMouseout(e) {
            const indicator = document.getElementById('legend-indicator');
            const hoverValue = document.getElementById('legend-hover-value');
            if (indicator) {
                indicator.style.display = 'none';
            }
            if (hoverValue) {
                hoverValue.style.display = 'none';
            }
        }

        function createPopupContent(props) {
            const name = props['Tên'] || 'N/A';
            const type = /xã/i.test(name) ? 'Xã' : 'Phường';
            const population = props['Dân số (người)'] ? props['Dân số (người)'].toLocaleString('vi-VN') : 'N/A';
            const area = props['Diện tích (km2)'] ? props['Diện tích (km2)'].toFixed(2) + ' km²' : 'N/A';
            const density = props['Mật độ (người/km2)'] ? Math.round(props['Mật độ (người/km2)']).toLocaleString('vi-VN') : 'N/A';
            const headquarters = props['Full Address 1'] || 'Chưa có thông tin';
            const lat = props['Latitude 1'];
            const lon = props['Longitude 1'];
            let html = `<div class="info-popup-header"><div class="info-popup-title">${type} ${name}</div></div>`;
            html += `<div class="info-popup-body">`;
            html += `<div class="info-line"><div class="info-label"><i class="fa-solid fa-users fa-fw"></i> <span>Dân số</span></div> <div class="info-value">${population}</div></div>`;
            html += `<div class="info-line"><div class="info-label"><i class="fa-solid fa-ruler-combined fa-fw"></i> <span>Diện tích</span></div> <div class="info-value">${area}</div></div>`;
            html += `<div class="info-line"><div class="info-label"><i class="fa-solid fa-users-viewfinder fa-fw"></i> <span>Mật độ</span></div> <div class="info-value">${density}</div></div>`;
            html += `<div class="info-section"><div class="info-label"><i class="fa-solid fa-location-dot fa-fw"></i> <span>Trụ sở</span></div>${headquarters}</div>`;
            html += `</div>`;
            if (lat && lon) {
                const navUrl = `https://www.google.com/maps/dir/?api=1&destination=${lat},${lon}`;
                html += `<div class="info-popup-footer"><a href="${navUrl}" target="_blank" class="navigate-btn"><i class="fa-solid fa-diamond-turn-right fa-fw"></i> Chỉ đường</a></div>`;
            }
            return html;
        }

        function createWardsLayer() {
            wardsLayer = L.geoJSON(wardData, {
                style: DEFAULT_WARD_STYLE, // Use the default style initially
                onEachFeature: (feature, layer) => {
                    const props = feature.properties;
                    const name = props['Tên'] || 'N/A';
                    const type = /xã/i.test(name) ? 'Xã' : 'Phường';
                    layer.bindTooltip(`${type} ${name}`);
                    layer.on({
                        mouseover: onWardMouseover,
                        mouseout: onWardMouseout,
                        click: (e) => {
                            L.DomEvent.stopPropagation(e); // Prevent map.on('click') from firing
                            showResultOnMap(null); // Clear any previous search highlight

                            // Clear search input and hide results list, as this click signifies a new focus
                            document.getElementById('wardSearchInput').value = '';
                            document.getElementById('search-results').style.display = 'none';
                            updateFocusedSearchResult(-1); // Clear visual focus from search list

                            const yPadding = document.getElementById('bottom-bar')?.clientHeight || 100;
                            L.popup({ className: 'info-popup', autoPanPadding: L.point(10, yPadding + 10) })
                                .setLatLng(e.latlng)
                                .setContent(createPopupContent(feature.properties))
                                .openOn(map);
                        }
                    });
                }
            }).addTo(map);
        }


        function handleNameSearch() {
            if (!wardData) {
                return;
            }
            currentFocusedResultIndex = -1; // Reset focused index on new search
            
            const query = document.getElementById('wardSearchInput').value;
            const resultsPanel = document.getElementById('search-results');
            if (query.trim().length < 2) {
                resultsPanel.style.display = 'none';
                showResultOnMap(null); // Clear highlight if query is too short
                return;
            }
            const normalizedQuery = normalizeString(query);
            
            // --- Step 1: Gather all admin matches (Provinces and Districts) ---
            let adminMatches = [];
            const adminSources = [
                { data: provinceData, type: 'province' },
                { data: districtData, type: 'district' }
            ];

            for (const source of adminSources) {
                if (source.data && source.data.features) {
                    for (const feature of source.data.features) {
                        const adminName = feature.properties.name || '';
                        const normalizedAdminName = normalizeString(adminName);
                        let isMatch = false;

                        if (normalizedAdminName === normalizedQuery) { // Exact normalized name match
                            isMatch = true;
                        } else if (normalizedQuery.startsWith("tp ") && normalizedAdminName === normalizedQuery.substring(3).trim()) { // Query "tp X", data "X"
                            isMatch = true;
                        } else if (normalizedQuery.startsWith("quan ") && normalizedAdminName === normalizedQuery.substring(5).trim()) { // Query "quan X", data "X"
                            isMatch = true;
                        } else if (normalizedQuery.startsWith("huyen ") && normalizedAdminName === normalizedQuery.substring(6).trim()) { // Query "huyen X", data "X"
                            isMatch = true;
                        } else if (isAccurateMatch(normalizedQuery, normalizedAdminName)) { // General fuzzy match (e.g., query "X", data "tp X")
                            isMatch = true;
                        }

                        if (isMatch) {
                            adminMatches.push({
                                feature: feature,
                                type: source.type,
                                displayName: adminName,
                                normalizedDisplayName: normalizedAdminName
                            });
                        }
                    }
                }
            }

            // --- Step 2: Determine if wards should be suppressed and select admin results ---
            let suppressWards = false;
            let finalAdminDisplayItems = [];

            const queryIsPrefixed = normalizedQuery.startsWith("tp ") || normalizedQuery.startsWith("quan ") || normalizedQuery.startsWith("huyen ");

            if (queryIsPrefixed) {
                // Query looks like "tp X", "quan X", or "huyen X"
                const queryNamePart = normalizedQuery.substring(normalizedQuery.indexOf(" ") + 1).trim();
                
                finalAdminDisplayItems = adminMatches.filter(item => 
                    item.normalizedDisplayName === queryNamePart ||  // Admin data is "X"
                    item.normalizedDisplayName === normalizedQuery   // Admin data is "tp X" / "quan X" / "huyen X"
                );
                if (finalAdminDisplayItems.length > 0) {
                    suppressWards = true;
                }
            } else { 
                // Query is generic (e.g., "Tân Uyên")
                // Suppress wards if an admin item's normalized name *exactly* matches the generic query
                finalAdminDisplayItems = adminMatches.filter(item => item.normalizedDisplayName === normalizedQuery);
                if (finalAdminDisplayItems.length > 0) {
                    suppressWards = true;
                }
            }

            // --- Step 3: Build displayedSearchResults ---
            if (suppressWards) {
                displayedSearchResults = finalAdminDisplayItems; // Only these specific admin matches
            } else {
                // No suppression, or suppression condition not met strongly enough.
                // Show all adminMatches found by any criteria.
                displayedSearchResults = [...adminMatches]; 

                // Proceed to Ward Search
                if (wardData && wardData.features) {
                    wardData.features.forEach(feature => {
                        const props = feature.properties;
                        // Ensure 'Tên' exists and is a string before calling normalizeString
                        const newName = props['Tên'] || '';
                        const normalizedNewName = normalizeString(newName);
                        let matchedOldWardDirect = null;

                        const oldWardsAll = (props['Sáp nhập toàn bộ từ'] || '').split(',').map(w => w.trim()).filter(Boolean);
                        const oldWardsPartial = (props['Sáp nhập một phần từ'] || '').split(',').map(w => w.trim()).filter(Boolean);
                        const allOldWards = [...oldWardsAll, ...oldWardsPartial];

                        for (const ow of allOldWards) {
                            // Ensure 'ow' is a string before calling normalizeString
                            if (typeof ow === 'string' && isAccurateMatch(normalizedQuery, normalizeString(ow))) {
                                matchedOldWardDirect = ow;
                                break;
                            }
                        }
                        const matchedViaNewName = isAccurateMatch(normalizedQuery, normalizedNewName);

                        if (matchedViaNewName || matchedOldWardDirect) {
                            displayedSearchResults.push({ 
                                feature: feature,
                                type: 'ward',
                                displayName: newName,
                                matchedOldWardDirect: matchedOldWardDirect,
                                matchedViaNewName: matchedViaNewName
                            });
                        }
                    });
                }
            }

            // Sort displayedSearchResults:
            // Priority: Ward (old) > Ward (new) > District > Province, then alphabetically
            displayedSearchResults.sort((a, b) => {
                const getPriority = (item) => {
                    if (item.type === 'province') return 0; // Highest priority
                    if (item.type === 'district') return 1; // Second highest
                    if (item.type === 'ward' && item.matchedOldWardDirect) return 2; // Ward matched by old name
                    if (item.type === 'ward') return 3; // Ward matched by new name
                    return 4; // Should ideally not happen
                };

                const priorityA = getPriority(a);
                const priorityB = getPriority(b);

                if (priorityA !== priorityB) {
                    return priorityA - priorityB;
                }

                // If priorities are the same, apply secondary sort
                if (priorityA === 2) { // Both are wards matched by old name (new priority 2)
                    const oldNameA = normalizeString(a.matchedOldWardDirect);
                    const oldNameB = normalizeString(b.matchedOldWardDirect);
                    if (oldNameA !== oldNameB) return oldNameA.localeCompare(oldNameB);
                    // If old names are the same (e.g. query matches old name for multiple new wards),
                    // then sort by new display name
                }
                // Default secondary sort by display name for all other cases or if old names were identical
                return normalizeString(a.displayName).localeCompare(normalizeString(b.displayName));
            });

            // Render results
            if (searchHighlightLayer) { 
                map.removeLayer(searchHighlightLayer);
                searchHighlightLayer = null;
            }

            if (displayedSearchResults.length === 0) {
                resultsPanel.innerHTML = `<p class="p-4 text-center text-gray-500">Không tìm thấy kết quả.</p>`;
            } else {
                resultsPanel.innerHTML = `<ul class="space-y-1 p-2">${displayedSearchResults.map((item, index) => {
                    let displayHtml = '';
                    let typeText = '';

                    if (item.type === 'ward') {
                        typeText = 'Phường/Xã sau sáp nhập';
                        displayHtml = `<span class="font-semibold">${item.displayName}</span>`; // Ward Name

                        // Display the type label first
                        displayHtml += `<span class="text-xs text-indigo-500 block font-medium">${typeText}</span>`;

                        if (item.matchedOldWardDirect) {
                            const props = item.feature.properties;
                            const oldWardsAll = (props['Sáp nhập toàn bộ từ'] || '').split(',').map(w => w.trim()).filter(Boolean);
                            const oldWardsPartial = (props['Sáp nhập một phần từ'] || '').split(',').map(w => w.trim()).filter(Boolean);
                            const allOldWardsList = [...oldWardsAll, ...oldWardsPartial];
                            
                            const countOfOtherOldWards = allOldWardsList.filter(ow => ow !== item.matchedOldWardDirect).length;

                            let sápNhapText = `Sáp nhập từ ${item.matchedOldWardDirect}`;
                            if (countOfOtherOldWards > 0) {
                                sápNhapText += ` và ${countOfOtherOldWards} phường/xã khác`;
                            }
                            displayHtml += `<span class="text-xs text-gray-500 block">${sápNhapText}</span>`;
                        }
                    } else if (item.type === 'district') {
                        typeText = 'Quận/Huyện';
                        displayHtml = `<span class="font-semibold">${item.displayName}</span><span class="text-xs text-teal-600 block font-medium">${typeText}</span>`;
                    } else if (item.type === 'province') {
                        typeText = 'Tỉnh/Thành phố';
                        displayHtml = `<span class="font-semibold">${item.displayName}</span><span class="text-xs text-purple-600 block font-medium">${typeText}</span>`;
                    }
                    return `<li><button id="search-result-item-${index}" onclick='handleSearchResultClick(${index})' class="w-full text-left p-3 hover:bg-indigo-50 rounded-lg text-gray-700 focus:outline-none">${displayHtml}</button></li>`;
                }).join('')}</ul>`;
            }
            resultsPanel.style.display = 'block';
        }

        function handleSearchResultClick(index) {
            if (index < 0 || index >= displayedSearchResults.length) return;

            const item = displayedSearchResults[index];
            if (item && item.feature) {
                showResultOnMap(item.feature, item.type);
                document.getElementById('search-results').style.display = 'none';
                document.getElementById('wardSearchInput').value = item.displayName;
            }
        }

        function showResultOnMap(feature, featureType = 'ward') { // Added featureType
            if (searchHighlightLayer) {
                map.removeLayer(searchHighlightLayer);
                searchHighlightLayer = null;
            }
            if (!feature) {
                return;
            }

            let style, tooltipText;
            const props = feature.properties;

            if (featureType === 'province') {
                style = { color: '#800080', weight: 3, opacity: 1, fillOpacity: 0.25, fillColor: '#800080' }; // Purple for province
                tooltipText = `Tỉnh/TP: ${props.name || 'N/A'}`; // Use 'name' from GeoJSON
            } else if (featureType === 'district') {
                style = { color: '#008080', weight: 3, opacity: 1, fillOpacity: 0.3, fillColor: '#008080' }; // Teal for district
                tooltipText = `Quận/Huyện: ${props.name || 'N/A'}`; // Use 'name' from GeoJSON
            } else { // Default to ward
                style = { color: '#fde047', weight: 4, opacity: 1, fillColor: '#facc15', fillOpacity: 0.5 };
                const wardName = props['Tên'] || 'N/A';
                const namePrefix = /xã/i.test(wardName) ? 'Xã' : 'Phường';
                tooltipText = `${namePrefix} ${wardName}`;
            }

            searchHighlightLayer = L.geoJSON(feature, { 
                style: style,
                interactive: false // Make sure this layer doesn't interfere with ward popups
            });
            searchHighlightLayer.feature = feature; // Store feature for potential checks

            searchHighlightLayer.bindTooltip(tooltipText, {
                permanent: true,
                direction: 'center',
                className: 'ward-label', // Can reuse or create new class
                offset: [0, 0] 
            }).addTo(map);

            const yPadding = (document.getElementById('bottom-bar')?.clientHeight || 100) + 20;
            const xPadding = 20;
            map.flyToBounds(searchHighlightLayer.getBounds(), {
                paddingTopLeft: [xPadding, 80],
                paddingBottomRight: [xPadding, yPadding]
            });
        }

        function initializeInsetMap() {
            insetMapContainerElement = document.getElementById('inset-map-container');
            if (!conDaoFeatureForInset || !insetMapContainerElement) {
                if (insetMapContainerElement) insetMapContainerElement.style.display = 'none';
                return;
            }

            insetMap = L.map('inset-map', {
                attributionControl: false, zoomControl: false, dragging: false,
                touchZoom: false, scrollWheelZoom: false, doubleClickZoom: false,
                boxZoom: false, keyboard: false, tap: false
            });

            // Optional: Add a very simple base layer for context, or none for just the shape
            L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
                 maxZoom: 20 // Adjust maxZoom as needed for the inset scale
            }).addTo(insetMap);

            conDaoLayerOnInset = L.geoJSON(conDaoFeatureForInset, { style: CON_DAO_INSET_STYLE }).addTo(insetMap);
            insetMap.fitBounds(conDaoLayerOnInset.getBounds(), { padding: [5, 5] }); // Minimal padding

            updateInsetMapVisibility(); // Initial check
        }

        function updateInsetMapVisibility() {
            if (!map || !conDaoFeatureForInset || !insetMapContainerElement || !insetMap) {
                if (insetMapContainerElement) insetMapContainerElement.style.display = 'none';
                return;
            }

            const conDaoMainMapBounds = L.geoJSON(conDaoFeatureForInset).getBounds();

            if (map.getBounds().intersects(conDaoMainMapBounds)) {
                insetMapContainerElement.style.display = 'none';
            } else {
                insetMapContainerElement.style.display = 'block';
                // Ensure inset map is properly sized if it was hidden
                insetMap.invalidateSize();
                // Re-fit bounds
                if (conDaoLayerOnInset) {
                     insetMap.fitBounds(conDaoLayerOnInset.getBounds(), { padding: [5, 5] });
                }
            }
        }

        function updateTileLayer() {
            if (!map) return;

            const zoom = map.getZoom();
            let newTileUrl;

            if (zoom <= 11) { // Zoom 9 and 10 (and anything less if minZoom allows)
                newTileUrl = 'https://{s}.basemaps.cartocdn.com/rastertiles/voyager_nolabels/{z}/{x}/{y}{r}.png';
            } else { // Zoom > 10
                newTileUrl = 'https://mt.google.com/vt/lyrs=m&x={x}&y={y}&z={z}';
            }

            if (currentTileLayer) {
                map.removeLayer(currentTileLayer);
            }

            currentTileLayer = L.tileLayer(newTileUrl, {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
                subdomains: 'abcd',
                maxZoom: 20 // Carto maxZoom is typically 20
            }).addTo(map);
        }

        function updateFocusedSearchResult(newIndex) {
            const resultsPanel = document.getElementById('search-results');
            if (!resultsPanel || resultsPanel.style.display === 'none' || displayedSearchResults.length === 0) {
                return;
            }

            // Remove focus from the previously focused item
            if (currentFocusedResultIndex !== -1) {
                const prevFocusedItem = document.getElementById(`search-result-item-${currentFocusedResultIndex}`);
                if (prevFocusedItem) {
                    prevFocusedItem.classList.remove('focused-search-result');
                }
            }

            currentFocusedResultIndex = newIndex;

            // Add focus to the new item
            if (currentFocusedResultIndex !== -1) {
                const newFocusedItem = document.getElementById(`search-result-item-${currentFocusedResultIndex}`);
                if (newFocusedItem) {
                    newFocusedItem.classList.add('focused-search-result');
                    newFocusedItem.scrollIntoView({ block: 'nearest', inline: 'nearest' });
                }
            }
        }


        document.getElementById('wardSearchInput').addEventListener('focus', handleNameSearch);
        document.getElementById('wardSearchInput').addEventListener('keyup', (event) => {
            // Don't re-trigger search if an arrow key (used for navigation) or Enter/Escape was just pressed.
            // These are handled by the keydown listener.
            if (event.key === 'ArrowDown' || event.key === 'ArrowUp' || event.key === 'Enter' || event.key === 'Escape') {
                return;
            }
            handleNameSearch(); // Otherwise, proceed with search logic
        });
        document.getElementById('wardSearchInput').addEventListener('keydown', (event) => {
            const resultsPanel = document.getElementById('search-results');
            if (resultsPanel.style.display !== 'block' || displayedSearchResults.length === 0) {
                return;
            }

            if (event.key === 'ArrowDown') {
                event.preventDefault();
                let newIndex = currentFocusedResultIndex + 1;
                if (newIndex >= displayedSearchResults.length) newIndex = 0; // Loop to top
                updateFocusedSearchResult(newIndex);
            } else if (event.key === 'ArrowUp') {
                event.preventDefault();
                let newIndex = currentFocusedResultIndex - 1;
                if (newIndex < 0) newIndex = displayedSearchResults.length - 1; // Loop to bottom
                updateFocusedSearchResult(newIndex);
            } else if (event.key === 'Enter') {
                event.preventDefault();
                if (currentFocusedResultIndex !== -1) {
                    handleSearchResultClick(currentFocusedResultIndex);
                }
            } else if (event.key === 'Escape') {
                resultsPanel.style.display = 'none';
                updateFocusedSearchResult(-1); // Clear focus
            }
        });

        document.getElementById('heatmap-controls').addEventListener('click', e => {
            if (e.target.tagName === 'BUTTON') {
                document.querySelectorAll('#heatmap-controls button').forEach(btn => btn.classList.remove('active'));
                e.target.classList.add('active');
                renderMapVisualization();
            }
        });

        document.addEventListener('click', function(event) {
            const searchContainer = document.getElementById('search-container');
            const resultsPanel = document.getElementById('search-results');
            const wardSearchInput = document.getElementById('wardSearchInput');
            const mapContainer = document.getElementById('map');

            const isClickOnPopup = event.target.closest('.leaflet-popup-pane');

            // If the click is outside the search container AND not on a map popup
            if (!searchContainer.contains(event.target) && !isClickOnPopup) {
                resultsPanel.style.display = 'none';
                updateFocusedSearchResult(-1); // Clear visual focus from search list

                // If the click was also not on the map itself, then clear search input and highlight.
                // Clicks on the map are handled by map.on('click').
                if (!mapContainer.contains(event.target)) {
                    wardSearchInput.value = ''; // Clear search input text
                    showResultOnMap(null);      // Clear map highlight
                }
            }
        });

        async function initializeApp() {
            setLoading(true);
            
            // Load data first to calculate bounds
            await loadData();
            if (!wardData || !wardData.features || wardData.features.length === 0) {
                setLoading(false);
                alert("Không có dữ liệu địa lý để hiển thị bản đồ.");
                return;
            }

            // Calculate the center of all ward data
            const tempLayer = L.geoJSON(wardData);
            const dataBounds = tempLayer.getBounds();

            // Add padding to the dataBounds. 0.05 means 5% padding on all sides.
            const PADDING_RATIO = 0.2;
            const paddedBounds = dataBounds.pad(PADDING_RATIO);
            
            map = L.map('map', {
                center: [10.78, 106.78],
                zoom: 9,
                attributionControl: false,
                zoomControl: false
            });

            map.setMaxBounds(paddedBounds); // Lock map to the PADDED bounds of the data
            map.options.maxBoundsViscosity = 1.0; // Make bounds feel like a hard stop
            map.options.minZoom = 9;      // Set a minimum zoom level (e.g., initial zoom)
            map.options.maxZoom = 18;     // Set a maximum zoom level
            
            L.control.zoom({ position: 'topright' }).addTo(map);

            updateTileLayer(); // Set initial tile layer

            map.on('click', () => {
                showResultOnMap(null); 
                document.getElementById('search-results').style.display = 'none';
                document.getElementById('wardSearchInput').value = '';
                document.getElementById('wardSearchInput').blur(); // Remove focus from input
                updateFocusedSearchResult(-1); // Clear visual focus from search list
            });

            createWardsLayer();
            initializeInsetMap(); // Initialize the inset map after main map and data

            if (map && conDaoFeatureForInset) { // Add listeners if inset is possible
                map.on('moveend', updateInsetMapVisibility);
                map.on('zoomend', updateTileLayer); // Update tile layer on zoom change
                map.on('zoomend', updateInsetMapVisibility);
            }
            document.getElementById('btn-density').classList.add('active');
            renderMapVisualization();
            setLoading(false);
        }

        initializeApp();
    </script>
</body>
</html>
